---
title: ES6
date: 2018-08-29 11:58:34
tags: ES6
---

# JS组成
- ECMAScript+BOM+DOM
- DOM Document Object Model
- Bom Browser Object Model  
# 变量的声明
* 存在的问题
  1.  变量的提升（在其它大部分语言中，变量没有提升的情况，所以-》养成先声明，后使用的习惯）
  2.  不存在块级作用域（在其它大部分语言中，代码块中的变量具有块级作用域，即在代码块中声明的变量只能在代码块中访问，之外访问不到，即变量具有块级作用域）
* 解决办法
  1.  取代var变量的声明方式，用let、const代替
  2.  二者都能解决以上存在的问题
  3.  let声明的变量可以改变，但不能再声明
  4.  const声明的为**常量**，一经声明无法再修改（如果存储的为引用类型，可改变其值，但不可改变路径）
  5.  **二则均不存在，变量的提升**
  6.  块级作用域的应用，循环中用于获取各项的索引
# 字面量对象增加的功能
* 当对象中属性名和属性值的变量名一致时，可以直接省略写成{属性名，属性名}
# 扩展运算符
- 将数组或对象中的数组、对象转换成参数列表的形式（扩展数组或对象）（...array/...object）
# rest  接收多出的实参，（并将他们整合进一个数组中）（只能放在最后，否则报错）
- ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
# 变量的结构赋值
- ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
- 如果解构不成功，变量的值就等于undefined
- 解构不仅可以用于数组，还可以用于对象。
# 函数参数的默认值
- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。
# 箭头函数
- **箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this**
- ES6 允许使用“箭头”（=>）定义函数。
- 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
- 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
- **不适宜使用**
  - 对象的方法，会将this指向window
- **this指向**
  - 事件执行的函数（this会指向window）
# 深拷贝数组、对象
* JSON.parse(JSON.stringify(arr/object))
* 先将json对象转换成字符串，再转换成json对象，然后赋值给变量，实现数组或对象的深拷贝
* Object.assign()类似jQuery中$.extend
  * Object.assign()用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标的对象
  * Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。
  * 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
  * 如果只有一个参数，Object.assign会直接返回该参数。
  * 如果该参数不是对象，则会先转成对象，然后返回。
  * 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错
  * 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。
  * 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
# forEach
- forEach替代for循环
- forEach中有一个参数为callback
- 三个参数-value、index、arr分别代表数组中的值，索引下标，数组本身
# map
- 从数组中生成新的数组（返回的是基于数组生成的新数组）
- map包含了隐藏的遍历（对每个只进行判断）
- map得到的新数组中，就是map中函数的返回值
# filter
- 筛选数组中符合条件的值，并产生一个新的数组
- filter的回调函数中只能返回true或则false
- 只有回调中返回的是true，对应的那次遍历的value才会被添加到新数组中
# some、every
- some判断数组中是否有值符合条件
  - 遍历结果中有一个返回值是true，结果为true
- every判断数组中是否所有的值都符合条件
  - 遍历函数中有一个返回值是false，结果为false
# reduce、reduceRight
- reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
  - 注意: reduce() 对于空数组是不会执行回调函数的。
- reduceRight
  - 从右到左
# fill
- 用于将数组中特定位置的元素替换成同一个
- 会改变原数组  
# promise
- 含义
  - Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大（回调函数解决异步会形成回调地狱，即代码冗余）
  - 三种状态（不受外界影响，其他手段无法改变-》promise（承诺））
    - pending（进行中）
    - fulfilled（已成功）
    - rejected（已失败）
  - 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
  - **promise实现阔以链式调用，是因为上一步操作完成后，返回的仍是对应的promise对象**
- 缺点
  - 无法取消promise，一旦新建就会立即执行，无法中途取消
  - 如果不设置回调函数，promise内部抛出的问题，不会反应到外部
  - 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） 
- 用法
  - ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
  - romise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
  - resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；success成功函数，在成功时调用
  - reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去；error失败函数，在失败时调用该函数
  - Promise实例生成以后，可以用then方法指定resolved状态，catch指定rejected状态的回调函数。
  - finally函数，finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
# Promise.all()
- 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
- 只有其中多个Promise实例状态改变时，all才会改变
# async-await
- 定义
  - async用来表示函数是异步的，定义的函数会返回一个promise对象，可以使用then方法添加回调函数。
  - await 可以理解为是 async wait 的简写。
  - await 必须出现在 async 函数内部，不能单独使用。
  - await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。
  - 如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行。
  - async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性。
  - async-await 是建立在 promise机制之上的，并不能取代其地位。
  - **通过将代码放置于try中，于catch中得到错误信息，并执行对应处理程序**
  -  try可以用来捕获js异常
  -  捕获后会将错误给catch (error)
  -  error就是try中捕获到的错误信息
  -  优点：
  -  不会中止代码的执行，使代码变得更强壮(不会因为报错阻，塞代码的运行)
# Axios
- Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。
- then（成功后执行函数）
- catch（失败执行）
- GET请求，参数可置于url？之后 或/或       url，{params：{参数：值}}-》params中
- POST请求（后台只能接收前端模仿成浏览器form表单的post请求）（$GLOBALS["HTTP_RAW_POST_DATA"]）(后台改变接收方式)/（axios.post("/api/lockServer/search","userName="'admin'&pwd='admin'")）